using GraphDecomposition.GraphElements;
using GraphDecomposition.Utils;


namespace GraphDecomposition.Algorithms
{
    public class Skolem
    {
        /// <summary>
        /// Number of vertices in a graph
        /// </summary>
        private int v;

        /// <summary>
        /// Number of triples in a STS(v)
        /// </summary>
        private int b;

        /// <summary>
        /// n defines the number of iterations of the construction
        /// </summary>
        private int n;

        /// <summary>
        /// Quasigroup matrix used for Skolem construction
        /// </summary>
        private Quasigroup quasigroup;

        /// <summary>
        /// Stores the generated triples
        /// </summary>
        private SteinerTripleSystem sts;

        /// <summary>
        /// Starts the Skolem construction
        /// </summary>
        /// <param name="v">Number of vertices in a graph</param>
        /// <returns>STS(v) generated by the construction</returns>
        public SteinerTripleSystem StartAlgorithm(int v)
        {
            this.v = v;
            this.n = (v - 1) / 6;
            this.b = v * (v - 1) / 6;
            this.quasigroup = new Quasigroup(2 * n);
            this.sts = new SteinerTripleSystem(b);

            CreateTypeOne();

            CreateTypeTwo();

            CreateTypeThree();

            return this.sts;

        }

        /// <summary>
        /// Creates type one triples
        /// </summary>
        private void CreateTypeOne()
        {
            for (int i = 1; i <= n; i++)
            {
                int firstVertex = ConstructionUtils.VertexNumberFromIndexSkolem(i, 1);
                int secondVertex = ConstructionUtils.VertexNumberFromIndexSkolem(i, 2);
                int thirdVertex = ConstructionUtils.VertexNumberFromIndexSkolem(i, 3);
                this.sts.AddTriple(firstVertex, secondVertex, thirdVertex);
            }
        }

        /// <summary>
        /// Creates type two triples
        /// </summary>
        private void CreateTypeTwo()
        {
            for (int i = 1; i <= n; i++)
            {
                int firstVertex = ConstructionUtils.VertexNumberFromIndexSkolem(0, 0);
                int secondVertex = ConstructionUtils.VertexNumberFromIndexSkolem(n + i, 1);
                int thirdVertex = ConstructionUtils.VertexNumberFromIndexSkolem(i, 2);
                this.sts.AddTriple(firstVertex, secondVertex, thirdVertex);


                firstVertex = ConstructionUtils.VertexNumberFromIndexSkolem(0, 0);
                secondVertex = ConstructionUtils.VertexNumberFromIndexSkolem(n + i, 2);
                thirdVertex = ConstructionUtils.VertexNumberFromIndexSkolem(i, 3);
                this.sts.AddTriple(firstVertex, secondVertex, thirdVertex);

                firstVertex = ConstructionUtils.VertexNumberFromIndexSkolem(0, 0);
                secondVertex = ConstructionUtils.VertexNumberFromIndexSkolem(n + i, 3);
                thirdVertex = ConstructionUtils.VertexNumberFromIndexSkolem(i, 1);
                this.sts.AddTriple(firstVertex, secondVertex, thirdVertex);
            }
        }

        /// <summary>
        /// Creates type tree triples
        /// </summary>
        private void CreateTypeThree()
        {
            for (int i = 1; i <= 2 * n; i++)
            {
                for (int j = i + 1; j <= 2 * n; j++)
                {
                    int firstVertex = ConstructionUtils.VertexNumberFromIndexSkolem(i, 1);
                    int secondVertex = ConstructionUtils.VertexNumberFromIndexSkolem(j, 1);
                    int thirdVertex = ConstructionUtils.VertexNumberFromIndexSkolem(this.quasigroup.GetElement(i,j), 2);
                    this.sts.AddTriple(firstVertex, secondVertex, thirdVertex);

                    firstVertex = ConstructionUtils.VertexNumberFromIndexSkolem(i, 2);
                    secondVertex = ConstructionUtils.VertexNumberFromIndexSkolem(j, 2);
                    thirdVertex = ConstructionUtils.VertexNumberFromIndexSkolem(this.quasigroup.GetElement(i, j), 3);
                    this.sts.AddTriple(firstVertex, secondVertex, thirdVertex);

                    firstVertex = ConstructionUtils.VertexNumberFromIndexSkolem(i, 3);
                    secondVertex = ConstructionUtils.VertexNumberFromIndexSkolem(j, 3);
                    thirdVertex = ConstructionUtils.VertexNumberFromIndexSkolem(this.quasigroup.GetElement(i, j), 1);
                    this.sts.AddTriple(firstVertex, secondVertex, thirdVertex);
                }
            }
        }

    }
}
