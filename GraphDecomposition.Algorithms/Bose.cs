using GraphDecomposition.GraphElements;
using GraphDecomposition.Utils;

namespace GraphDecomposition.Algorithms
{
    public class Bose
    {
        /// <summary>
        /// Number of vertices in a graph
        /// </summary>
        private int v;

        /// <summary>
        /// Number of triples in a STS(v)
        /// </summary>
        private int b;

        /// <summary>
        /// n defines the number of iterations of the construction
        /// </summary>
        private int n;

        /// <summary>
        /// Quasigroup matrix used for Skolem construction
        /// </summary>
        private Quasigroup quasigroup;

        /// <summary>
        /// Stores the generated triples
        /// </summary>
        private SteinerTripleSystem sts;

        /// <summary>
        /// Starts the Bose construction
        /// </summary>
        /// <param name="v">Number of vertices in a graph</param>
        /// <returns>STS(v) generated by the construction</returns>
        public SteinerTripleSystem StartAlgorithm(int v)
        {
            this.v = v;
            this.n = (v - 3) / 6;
            this.b = v * (v - 1) / 6;
            this.quasigroup = new Quasigroup(2 * n + 1);
            this.sts = new SteinerTripleSystem(b);

            CreateTypeOne();
            CreateTypeTwo();

            return this.sts;

        }

        /// <summary>
        /// Creates type one triples
        /// </summary>
        private void CreateTypeOne()   
        {
            for (int i = 1; i <= 2 * n + 1; i++)
            {
                int firstVertex = ConstructionUtils.VertexNumberFromIndexBose(i, 1);
                int secondVertex = ConstructionUtils.VertexNumberFromIndexBose(i, 2);
                int thirdVertex = ConstructionUtils.VertexNumberFromIndexBose(i, 3);
                this.sts.AddTriple(firstVertex, secondVertex, thirdVertex);
            }
        }

        /// <summary>
        /// Creates type two triples
        /// </summary>
        private void CreateTypeTwo()
        {
            for (int i = 1; i <= 2 * n + 1; i++)
            {
                for (int j = i + 1; j <= 2 * n + 1; j++)
                {

                    int firstVertex = ConstructionUtils.VertexNumberFromIndexBose(i, 1);
                    int secondVertex = ConstructionUtils.VertexNumberFromIndexBose(j, 1);
                    int thirdVertex = ConstructionUtils.VertexNumberFromIndexBose(this.quasigroup.GetElement(i, j), 2);
                    this.sts.AddTriple(firstVertex, secondVertex, thirdVertex);


                    firstVertex = ConstructionUtils.VertexNumberFromIndexBose(i, 2);
                    secondVertex = ConstructionUtils.VertexNumberFromIndexBose(j, 2);
                    thirdVertex = ConstructionUtils.VertexNumberFromIndexBose(this.quasigroup.GetElement(i, j), 3);
                    this.sts.AddTriple(firstVertex, secondVertex, thirdVertex);

                    firstVertex = ConstructionUtils.VertexNumberFromIndexBose(i, 3);
                    secondVertex = ConstructionUtils.VertexNumberFromIndexBose(j, 3);
                    thirdVertex = ConstructionUtils.VertexNumberFromIndexBose(this.quasigroup.GetElement(i, j), 1);
                    this.sts.AddTriple(firstVertex, secondVertex, thirdVertex);
                }
            }
        }
    }
}
